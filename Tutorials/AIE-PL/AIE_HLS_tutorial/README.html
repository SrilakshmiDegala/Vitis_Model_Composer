<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="/proj/xcoswmktg/robg/git/markdown_to_html/style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<table class="sphinxhide" width="100%">
 <tr width="100%">
    <td align="center"><img src="https://raw.githubusercontent.com/Xilinx/Image-Collateral/main/xilinx-logo.png" width="30%"/><h1>AI Engine Development</h1>
    <a href="https://www.xilinx.com/products/design-tools/vitis.html">See Vitis™ Development Environment on xilinx.com</br></a>
    <a href="https://www.xilinx.com/products/design-tools/vitis/vitis-ai.html">See Vitis™ AI Development Environment on xilinx.com</a>
    </td>
 </tr>
</table>

<section id="connecting-ai-engine-and-hls-subsystems" class="level1">
<h1>Connecting AI Engine and HLS Subsystems</h1>
<p>This tutorial will explore how to model heterogeneous systems
(consisting of AI Engine and PL components) in Vitis Model Composer.</p>
<p>This tutorial will show how to use the <strong>AIE to HLS</strong>
and <strong>HLS to AIE</strong> blocks to connect the HLS and AIE
simulation domains to accurately model how the AIE-PL interface will
behave in hardware.</p>
<section id="review-the-tutorial-model" class="level2">
<h2>Review the Tutorial Model</h2>
<ol type="1">
<li><p>Open the model <code>AIE_HLS.slx</code>.</p></li>
<li><p>Right-click on an empty part of the canvas. In the context menu
that displays, ensure that the following options are selected:</p></li>
</ol>
<ul>
<li><strong>Sample Time Display -&gt; All</strong></li>
<li><strong>Other Displays -&gt; Signals &amp; Ports -&gt; Signal
Dimensions</strong></li>
<li><strong>Other Displays -&gt; Signals &amp; Ports -&gt; Port Data
Types</strong>.</li>
</ul>
<ol start="3" type="1">
<li><p>On the <strong>Modeling tab</strong>, select <strong>Update
Model</strong>.</p></li>
<li><p>Open the <strong>Timing Legend</strong> by pressing
<code>Ctrl+J</code>.</p></li>
</ol>
<p>This model implements a simple passthrough design that sends integer
data from the PL to the AI Engine and back.</p>
<p><img src="./Images/model1.png" /></p>
<p>The interfaces between the AI Engine and HLS parts of the design are
initially implemented with placeholder blocks. In this tutorial, we will
see how to replace these placeholders with the <strong>HLS to
AIE</strong> and <strong>AIE to HLS</strong> blocks.</p>
</section>
<section id="hls-kernel-block" class="level2">
<h2>HLS Kernel Block</h2>
<p>In order to interface a PL kernel written in HLS with an AI Engine
design, the PL kernel must be brought into Vitis Model Composer using
the <strong>HLS Kernel</strong> block. This block lets you import HLS
C/C++ code that is compiled and executed when simulating the Simulink
model. The simulation of the HLS Kernel in Simulink is not
cycle-accurate.</p>
<blockquote>
<p><strong>IMPORTANT:</strong> Vitis Model Composer also allows you to
import HLS code into your design using the
<code>xmcImportFunction</code>, or to build a design out of blocks from
the HLS block library. <strong>These approaches are not supported for
connecting an HLS design to the AI Engine.</strong> For a detailed
discussion on the differences between these approaches and using the
<strong>HLS Kernel</strong> block, see <a
href="https://docs.xilinx.com/r/en-US/ug1483-model-composer-sys-gen-user-guide/Interconnecting-AI-Engines-and-HLS-Kernels">Interconnecting
AI Engines and HLS Kernels</a> in the Vitis Model Compouser User
Guide.</p>
</blockquote>
<ol start="4" type="1">
<li>Focus on the <strong>HLS_passthrough</strong> block on the
canvas.</li>
</ol>
<p><img src="./Images/HLS_passthrough2.png" /></p>
<p>The notations on the block canvas show that the HLS Kernel inputs and
outputs vectors of length 32.</p>
<p>According to the Timing Legend, the sample period of the HLS Kernel
block is 64 ns, corresponding to a sample rate of 15.625 MHz.</p>
<p><img src="./Images/model2.png" /></p>
<p>This sample rate is calculated by buffering the input signal (red
color, rate of 500 MHz) into vectors of 32 elements each. (500 MHz / 32
= 15.625 MHz) This calculated sample rate is used only for Simulink
simulation and does not have any relationship to the design running on
the hardware.</p>
<ol start="5" type="1">
<li>Double-click on the <strong>HLS_passthrough</strong> block.</li>
</ol>
<p><img src="./Images/HLS_passthrough1.png" /></p>
<p>The HLS Kernel's inputs and outputs are displayed. This function has
a streaming <code>int32</code> input and output. When this function is
implemented in hardware, it will have AXI4-Stream interfaces. For more
information, see <a
href="https://docs.xilinx.com/r/en-US/ug1399-vitis-hls/How-AXI4-Stream-Works">How
AXI4-Stream Works</a>. The function interfaces are determined from the
kernel's source code.</p>
<p>Also note that the HLS Kernel's output signal size is
<code>32</code>. This means that on each invocation of the kernel
function, it is expected to produce 32 <code>int32</code> values. This
parameter must be specified by the user.</p>
<p>We can confirm that the interfaces and output signal size are correct
by studying the HLS kernel function's source code.</p>
<ol start="6" type="1">
<li>Open the file <code>HLS_passthrough.cpp</code> and study the
function's source code. This function implements a simple passthrough
that sends the input data to the output, 32 integer values at a
time.</li>
</ol>
<pre><code>void
HLS_passthrough(hls::stream&lt; int &gt;&amp; arg0, hls::stream&lt; int &gt;&amp; arg1)
{
    #pragma HLS INTERFACE axis port=arg0
    #pragma HLS INTERFACE axis port=arg1
    #pragma HLS INTERFACE ap_ctrl_none port=return
    #pragma HLS dataflow
    int stream_adapter[32];
    #pragma HLS stream variable=stream_adapter depth=3
    xmc::StreamAdapter1d&lt;32&gt;::readStream(arg0, stream_adapter);
    xmc::StreamAdapter1d&lt;32&gt;::writeStream(arg1, stream_adapter);
}</code></pre>
<p>Note the following elements:</p>
<ul>
<li><code>hls::stream&lt; int &gt;&amp; arg0, hls::stream&lt; int &gt;&amp; arg1</code>:
The input and output are 32-bit integers implemented as
<code>hls::stream</code>s.</li>
<li><code>#pragma HLS INTERFACE axis port=arg0</code>,
<code>arg1</code>: These pragmas specify that the input and output
should be implemented as AXI4-Streams in hardware.</li>
<li><code>#pragma HLS INTERFACE ap_ctrl_none port=return</code>: This
pragma states that the kernel should execute in free-running mode, i.e.
not dependent on control signals.</li>
<li><code>xmc::StreamAdapter1d&lt;32&gt;::writeStream(arg1, stream_adapter)</code>:
The kernel writes 32 <code>int</code> values on each execution of the
function.</li>
</ul>
<p>These code elements fulfill some of the requirements for interfacing
an HLS Kernel to an AI Engine graph, namely:</p>
<ul>
<li>The kernel inputs and outputs should be implemented as
AXI4-Streams.</li>
<li>The kernel should execute in free-running mode.</li>
<li>The kernel should produce the number of outputs that is specified in
the HLS Kernel block on each invocation of the function.</li>
</ul>
<p>Additional requirements to interface an HLS Kernel with an AI Engine
graph are listed in <a
href="https://docs.xilinx.com/r/en-US/ug1483-model-composer-sys-gen-user-guide/Design-Considerations">Design
Considerations</a> in the Vitis Model Composer User Guide.</p>
</section>
<section id="aie-subsystem" class="level2">
<h2>AIE Subsystem</h2>
<p>We saw above that the HLS Kernel sample rate displayed in Simulink
does not correspond to the PL hardware clock rate. In a similar fashion,
the observed sample times for the AI Engine blocks do not correspond to
the AI Engine's hardware clock rate. In fact, in this Simulink model the
HLS Kernel blocks and AI Engine subsystem have the same sample rate,
despite the fact that in hardware the designs will be on different
clocks.</p>
<ol start="8" type="1">
<li>Return to the top-level <code>AIE_HLS</code> model and double-click
the <strong>AIE_Subsystem</strong> to open it.</li>
</ol>
<p>The AIE subsystem contains a single kernel that performs a simple
passthrough. You can view the AIE kernel code in the
<code>passthrough.cpp</code> file.</p>
<ol start="9" type="1">
<li>Double-click on the <strong>passthrough</strong> block.</li>
</ol>
<p><img src="./Images/aie_kernel.png" /></p>
<p>In the function declaration, note that this kernel's input and output
are <code>cint32</code> values. Also note the <code>FRAME_LENGTH</code>
parameter, set to 16, which also corresponds to the size of the input
and output buffers.</p>
<ol start="10" type="1">
<li>Close the <strong>passthrough</strong> block parameters and open the
first <strong>PLIO</strong> block.</li>
</ol>
<p><img src="./Images/plio.png" /></p>
<p>The PLIO block defines the hardware interface between the AI Engine
and the PL.</p>
<p>The <strong>PLIO width</strong> determines how much data is
transferred to the AI Engine on each PL clock cycle. For faster data
transfer, this value can be a multiple of the bit width of the HLS
kernel's output, as long as the AI Engine clock is fast enough to
accomodate the transfer. Here, <strong>PLIO width</strong> is
<code>64</code>, which means that 1 <code>cint32</code> value will be
transferred from the PL to the AIE on each PL clock cycle.</p>
<p>The <strong>PLIO frequency</strong> is 500 MHz, which matches the
expected rate of our PL clock (see above).</p>
<p>The combination of the PLIO width and frequency mean that the AI
Engine effectively consumes <code>cint32</code> values at a rate of 500
MHz.</p>
<blockquote>
<p><strong>IMPORTANT:</strong> The parameters specified in the PLIO
block do not affect the functional simulation or observed sample times
in Simulink. These parameters only affect the generated AI Engine graph
code and how the design is simulated in the cycle-approximate
<code>aiesimulator</code>.</p>
</blockquote>
<p>The second PLIO block is configured identically to transfer
<code>cint32</code> values from AIE to PL at a rate of 500 MHz.</p>
</section>
<section id="interface-from-hls-to-aie" class="level2">
<h2>Interface From HLS to AIE</h2>
<p>HLS Kernels and AI Engine kernels may operate on different data types
and vector lengths. In these situations, the <strong>HLS to AIE</strong>
and <strong>AIE to HLS</strong> blocks may be used to reformat the data
to the necessary type and length without losing any information.</p>
<p><img src="./Images/connectors_hls.png" /></p>
<p>For example, an HLS Kernel may operate on interleaved
<code>int32</code> samples of real and imaginary data while the AI
Engine expects a <code>cint32</code> data type (or vice versa).</p>
<ol start="11" type="1">
<li><p>Remove the <strong>HLS to AIE Placeholder</strong>
subsystem.</p></li>
<li><p>Click an open area of the canvas, type <code>HLS to AIE</code>,
and select the <strong>HLS to AIE</strong> block (or select the block
from the Simulink Library Browser).</p></li>
<li><p>Connect the <strong>HLS to AIE</strong> block where the
placeholder block used to be.</p></li>
</ol>
<p><img src="./Images/connection1.png" /></p>
<ol start="14" type="1">
<li>Double-click the <strong>HLS to AIE</strong> block to open its
parameters.</li>
</ol>
<p><img src="./Images/hls_aie_params1.png" /></p>
<ol start="15" type="1">
<li>Configure the block as follows:</li>
</ol>
<ul>
<li><strong>AIE Input Type:</strong> <code>cint32</code> The AI Engine
kernel expects a <code>cint32</code> input.</li>
<li><strong>Output Size:</strong> <code>16</code> The AI Engine kernel
expects an input vector of length 16. Since the HLS Kernel output is of
length 32, the HLS to AIE block will combine subsequent
<code>int32</code> samples into a single <code>cint32</code> sample,
without modifying or losing any data bits.</li>
</ul>
<p><img src="./Images/hls_aie_params2.png" /></p>
<ol start="16" type="1">
<li><p>Press <strong>Apply</strong> and <strong>OK</strong>.</p></li>
<li><p>Press <code>Ctrl+D</code> to update the model.</p></li>
</ol>
<p>The <strong>HLS to AIE</strong> block's sample times and output data
types and dimensions are updated:</p>
<p><img src="./Images/connection2.png" /></p>
<ul>
<li>The output sample rate (green color) is 15.625 MHz. This is the same
sample rate as the HLS Kernel; the HLS to AIE block is single-rate.</li>
<li>The output data type is <code>cint32</code>.</li>
<li>The output signal is a variable-sized signal with a maximum size of
<code>16</code>.</li>
</ul>
</section>
<section id="interface-from-aie-to-hls" class="level2">
<h2>Interface From AIE to HLS</h2>
<p>The bridge from AIE to HLS functions in a similar way.</p>
<ol start="18" type="1">
<li><p>Remove the <strong>AIE to HLS Placeholder</strong>
subsystem.</p></li>
<li><p>Click an open area of the canvas, type <code>AIE to HLS</code>,
and select the <strong>AIE to HLS</strong> block (or select the block
from the Simulink Library Browser).</p></li>
<li><p>Connect the <strong>AIE to HLS</strong> block where the
placeholder block used to be.</p></li>
</ol>
<p><img src="./Images/connection3.png" /></p>
<ol start="21" type="1">
<li>Double-click the <strong>AIE to HLS</strong> block to open its
parameters.</li>
</ol>
<p><img src="./Images/aie_hls_params1.png" /></p>
<ol start="22" type="1">
<li>Configure the block as follows:</li>
</ol>
<ul>
<li><strong>Output Data Type:</strong> <code>int32</code> The HLS Kernel
expects a <code>int32</code> input. The AIE to HDL block will combine
split each <code>cint32</code> input into subsequent <code>int32</code>
outputs.</li>
<li><strong>Output Size:</strong> <code>32</code> Because the input to
the AIE to HDL block is a variable-size <code>cint32</code> vector with
maximum length of 16, the <code>int32</code> output size must be at
least 32.</li>
</ul>
<p><img src="./Images/aie_hls_params2.png" /></p>
<ol start="23" type="1">
<li><p>Press <strong>Apply</strong> and <strong>OK</strong>.</p></li>
<li><p>Press <code>Ctrl+D</code> to update the model.</p></li>
</ol>
<p>The <strong>AIE to HLS</strong> block's sample times and output data
types and dimensions are updated:</p>
<p><img src="./Images/connection4.png" /></p>
<ul>
<li>The output sample rate (green color) is 15.625 MHz. This is the same
sample rate as the AI Engine design; the AIE to HLS block is
single-rate.</li>
<li>The output data type is <code>int32</code>.</li>
<li>The output signal is a variable-sized signal with a maximum size of
<code>32</code>.</li>
</ul>
</section>
<section id="key-takeaways" class="level2">
<h2>Key Takeaways</h2>
<ul>
<li>AI Engine and HLS Kernel simulations in Vitis Model Composer are not
cycle-accurate.</li>
<li>The Simulink sample rates for AI Engine and HLS Kernel blocks are
based on data flow, and do not correlate to hardware clock rates.</li>
<li>The <strong>PLIO</strong> block defines the bit width and clock rate
of the AIE-PL interface. This information is only used in the generated
code and cycle-approximate SystemC simulation; it has no bearing on the
Simulink simulation.</li>
<li>The <strong>AIE to HLS</strong> to <strong>HDL to AIE</strong>
blocks translate between HDL and AI Engine data types and vector
lengths.</li>
</ul>
<hr />
<p>© Copyright 2023 Advanced Micro Devices, Inc.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you
may not use this file except in compliance with the License. You may
obtain a copy of the License at</p>
<pre><code>    http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p>
</section>
</section>
</body>
</html>
